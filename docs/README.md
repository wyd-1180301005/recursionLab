# 递归算法转化为迭代算法的案例

- [递归算法转化为迭代算法的案例](#递归算法转化为迭代算法的案例)
  - [qucikSort算法的递归转化为迭代](#quciksort算法的递归转化为迭代)
  - [median算法的递归转化为迭代](#median算法的递归转化为迭代)

## qucikSort算法的递归转化为迭代

- 1.递归版本
  - quickSort实质上就是将一个长数组不断经过partition操作获得k(k一般等于2)个长度更小的数组,从而将原问题转化为k个较小的子问题
- 2.迭代优化
  - 每一个问题可以仅由二元组<st,ed>(数组的起止下标对)来表示
  - 使用变长的循环双端队列存储下标对对,有效地节省空间
  - 每次迭代,从队首抽取一个下标对,将以该下标对为起止的数组进行partition分割
  - 将partition后生成的k个子数组的起止下标对分别从队尾入队

## median算法的递归转化为迭代

- 1.递归版本
  - median算法本质上类似于quickSort算法,只是pivot的选取使用了中位数进行优化,确保pivot近似于中位数.算法一共需要两次递归调用,一次是非尾递归,一次是尾递归.
- 2.迭代优化
  - 每一个问题可以由三元组<st,ed,k>来表示.特别地,用一个三元组T0来表示当前算法要求解的问题
    - 记尾递归调用为pt
    - 记非尾递归调用为nt
    - 记递归终结为d
  - 则考虑该算法的递归过程:
    - [1] A::=d
    - [2] A::=(nt A pt)A
  - 根据递归过程,可以知道:
    - nt pt是一个调用对,调用nt时候入栈三元组
    - 子递归过程A结束后执行出栈,然后调用pt
    - 每一个子递归过程A的递归终结仅由(终结符)d触发
  - 由上述分析可知:
    - 迭代过程分为三个不同子过程
    - 需要使用一个bool类型变量刻画递归终结
    - 需要一个栈来储存nt调用前的原始问题
